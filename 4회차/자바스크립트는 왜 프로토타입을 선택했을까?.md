> 이 글은 임성묵님의 글을 보며 공부하면서 적었습니다!
>
> 원본 글은 [자바스크립트는 왜 프로토타입을 선택했을까?](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42) 를 확인해주세요!!

<br/>

프로토타입은 자바스크립트에서 상속을 지원하기 위한 방법입니다.

<br/>

하지만, 이것 만으로는 왜 클래스 대신 프로토타입을 사용하는지에 대해 설명할 수 없습니다.

<br/>

프로토타입 기반의 OOP는 클래스 기반의 OOP와는 완전히 상반되는 방식입니다.

<br/>

객체를 바라보는 개념 자체가 완전히 다릅니다.

<br/>

## 1. 클래스의 기원

<br/>

서양 철학은 이분법적인 세계관을 가지고 있습니다.

- 영혼 / 육체
- 추상적 / 구체적
- 이데아 / 프랙티스

<br/>

눈 앞에서 실제로, 구체적으로 존재하는 사물이 있다면 반드시 그것으로 본질이 존재한다는 플라톤의 주장

<br/>

예를 들어, 우리가 앉아 있는 의자로 예를 들어보면 원목 의자, 바퀴 달린 의자 등등 이러한 수많은 의자가 실제로 존재한다면 반드시 그 본질인 의자라는 것이 존재한다는 것입니다.

<br/>

이러한 본질의 세계를 이데아 라고 한다.

<br/>

이러한 본질의 세계를 이데이라고 하며, 현실의 의자는 모두 이데아의 의자를 모방한 의자라는 뜻.

<br/>

이러한 사고방식이 프로그래밍 언어에도 자연스럽게 녹아들어 생긴 언어가 클래스 기반 객체지향 프로그래밍 언어이며, Java, C#이 있습니다.

<br/>

### Java에서의 예

<br/>

```java
class Chair {
...
}
Chair myChair = new Chair();
```

<br/>

위 코드의 Chair 클래스는 이데아에 존재하는 추상적인 개념으로, 현실 세계의 의자를 만들기 위해서 우리는 의자라는 인스턴스화를 해야합니다.

<br/>

이러한 클래스 방식의 OOP 언어는 플라톤류 서양 철학의 자연스러운 흐름이 되는 것.

<br/>

### Classification

<br/>

이러한 플라톤의 이데아 이론은 그의 제자 아리스트텔레스에 의해 분류 ( Classification )라는 개념으로 정립됩니다.

<br/>

아리스토텔레스는 이 Classification에 대해 아래와 같이 정리하였습니다.

- 객체의 속성이 동일한 경우, 개체 그룹이 같은 범주에 속한다. 즉, 범주는 정의와 구별의 합입니다.

<br/>

객체의 속성 즉, 클래스의 프로퍼티와 유사한 객체가 있다면 일반화 과정을 통해 클래스로 추상화되게 되는 것입니다.

<br/>

실제로 아리스트텔레스는 이러한 기준으로 현실 세계의 많은 것들을 분류하였고, 이에 따라 동물을 분류하였습니다.

<br/>

이에 대한 대표적인 예로 돌고래로 꼽을 수 있습니다.

<br/>

돌고래가 어류가 아닌 포유류인 이유는 포유류와 공통적인 속성을 가지고 있기 때문에 포유류로 묶이게 된 것입니다.

<br/>

## 2. 프로토타입

<br/>

프로토타입이라는 개념은 아리스트텔레스가 말했던 Classification 이론을 정면으로 반박하여 나온 이론입니다.

<br/>

19세기 매우 유명한 철학자 비트겐슈타인은 아리스토텔레스의 Classification 개념을 정면으로 반박하게 됩니다.

<br/>

> 공유 속성의 관점에서 정의하기 어려운 개념이 있다. ( 사실상 올바른 분류란 없다 ) - 비트겐슈타인

<br/>

이 이야기를 하면서 근거로 들고 온 것은 바로 게임이론입니다.

<br/>

일반적으로 게임의 경우에는 승리와 패배가 명확합니다.

<br/>

하지만, 모든 게임이 그런 것은 아니다.

<br/>

만약, 승자가 없는 게임이라면..?

<br/>

대표적으로 ring around rosy로 들 수 있는데, 이 게임은 원을 그리며 노래하고 춤을 추다가 신호에 따라 웅크리는 놀이로 승리와 패배의 개념이 없는 게임입니다.

<br/>

특히 게임 외에도 예술작품의 경우 공통 속성을 정의할 수 없습니다.

<br/>

즉, 철학적으로 보았을 때 게임, 예술 등... **우리 주변의 많은 것들을 한 개의 단어로 규정할 수 없다.**

<br/>

그래서 **모든 것을 한 개의 클래스로 묶는 것은 생각보다 모든 것을 표현할 수 없습니다.**

<br/>

### 그럼, 대안은 과연 무엇일까?

<br/>

비트겐슈타인은 다음의 유명한 말을 남기게 된다.

<br/>

> 표현은 삶의 흐름 속에서만 의미를 갖는다. - 비트겐슈타인

<br/>

### 의미 사용이론

<br/>

이는 사용에 의해 의미가 결정된다는 이론으로 단어의 쓰임새가 곧 의미가 된다는 의미입니다.

<br/>

즉, **단어의 진정한 본래의 의미란 존재하지 않고, 상황과 맥락에 의해서 결정**된다라고 주장합니다.

<br/>

따라서, 단어의 의미는 고정적이지 않고 매번 상황에 따라 달라지게 되는것이죠..

<br/>

비트겐 슈타인은 벽돌을 예로 들었습니다. **누군가 벽돌! 이라 외쳤을 때 상황마다 그 의미는 달라집니다.**

<br/>

- ( 벽돌이 필요할 때 ) → 벽돌을 달라
- ( 벽돌로 보수해야 할 때 ) → 벽돌을 채우라
- ( 벽돌이 떨어질 때 ) → 벽돌을 피해라

<br/>

위와 같이 **같은 벽돌이라도 그 상황에 따라 벽돌에 대한 의미는 달라진다는 말**입니다.

<br/>

### 의미 사용이론

<br/>

비트겐슈타인은 위에서 설명한 의미사용이론과 또 하나 다른 **가족 유사성**을 주장합니다.

<br/>

![스크린샷 2022-05-26 오전 11.39.23.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fb8d5ccc-a6c4-4613-bf0e-126752ccb4c0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.39.23.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T045901Z&X-Amz-Expires=86400&X-Amz-Signature=8aee73dac9cef8ea17c3672eb3994a95201936beb9dd4857d0308760efe55136&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-26%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB%252011.39.23.png%22&x-id=GetObject)

<br/>

비트겐슈타인은 인간이 현실에서 실제로 대상을 분류할 때 속성이 아닌 가족 유사성을 통해 분류하게 된다고 이야기 합니다.

<br/>

위 그림처럼 가족이 있을 때 이 가족이 모두 공유하는 공통 속성은 없습니다.

<br/>

갈색 머리, 안경, 수염 큰 코가 가족의 전형적인 특징이라고 하더라도 **모든 가족 구성원에게 적용되는 공통된 특성은 없을 수 있습니다.**

<br/>

그런데도 우리는 **이 그림을 보고 전형적인 특징을 통해 가족으로 분류**합니다.

<br/>

이러한 분류 방식을 **가족 유사성에 의한 분류**라고 합니다.

<br/>

**이 이론은 프로토타입 이론의 근거가 됩니다.**

<br/>

### Rosch의 프로토타입 이론

<br/>

Rosch가 말하는 프로토타입 이론은 Javascript에서 사용하는 프로토타입 입니다.

<br/>

비트겐슈타인의 의미사용이론, **가족 유사성은 1970년경 철학자 Eleanor Rosch에 의해 프로토타입 이론 ( Prototype theroy )로 정리**됩니다.

<br/>

1975년, Rosch는 한 가지 실험을 합니다.

<br/>

- 실험 참가자들에게 여러 범주 구성원의 속성을 적어보라고 합니다. ( 사과, 코코넛, 오랜지 )
- 각 범주 구성원애 대해 범주의 다른 구성원과 공유하는 속성의 개수를 도출합니다.
- 사과, 오랜지 → 2점 ( 둥글다, 즙이 있다. )
- 코코넛 → 1점 ( 둥글다 )

<br/>

이와 같이 점수가 높을 수록 가족 유사성이 높다고 볼 수 있습니다.

<br/>

이 실험을 통해 Rosch는 인간은 등급이 매겨진 구조를 가진다라고 주장합니다.

<br/>

인간은 사물을 분류할 때 자연스럽게 가장 유사성이 높은 것 순서대로 등급을 매긴다는 의미로 볼 수 있습니다.

<br/>

이렇게 분류했을 때 **가장 높은 등급**을 가진 녀석이 나올 텐데, **이 것이 바로 원형 ( Prototype )이라는 주장이 프로토타입 이론**입니다.

<br/>

새로 예를 들어보겠습니다.

<br/>

참새는 새의 범주를 대표할 만한 가장 전형적입니다.

<br/>

이를 프로토타입으로 간주하겠습니다.

<br/>

![스크린샷 2022-05-26 오후 1.26.29.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/59fd9590-310c-441f-8620-2cf902ab2d64/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.26.29.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050013Z&X-Amz-Expires=86400&X-Amz-Signature=19007a1de40531f3c042d69cbfc0b83695e84619201d7fc69610a9a822be8c96&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-26%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.26.29.png%22&x-id=GetObject)

<br/>

타조는 **전통적인 분류에서는 같은 새**가 되지만, **프로토타입 이론에서는 원형에서 가장 멀리 떨어진,**

<br/>

**비 전형적인 것**이 됩니다.

<br/>

즉, 객체는 정의로부터 분류되는 것이 아니라 **가장 좋은 보기로부터 범주화 된다고 합니다.**

<br/>

이러한 분류 체계는 **매우 경제적**입니다.

<br/>

만약 우리가 새로운 대상을 접해서 분류해야 할 때, **우리는 새로운 대상의 몇 가지 특징만 원형과 비교확인**만 하면 됩니다.

<br/>

**특징이 다를수록 원형에서 멀리 떨어진 범주가 되는 거죠.**

<br/>

그리고 이에 대한 관점은 **같은 단어라 할지라도 누가 어떤 상황에서 접했나에 따라 의미가 달라질 수 있습니다.** ( 의미 사용 이론 )

<br/>

- 현실에 존재하는 것 중 가장 좋은 본보기를 원형 ( prototype )으로 선택한다.
- 문맥 ( 컨텍스트 )에 따라 의미가 달라질 수 있다.

<br/>

## 3. 프로토타입 기반 객체지향 프로그래밍

<br/>

이러한 프로토타입 이론은 그대로 프로토타입 기반 객체지향 프로그래밍 언어를 통해 구현되었습니다.

<br/>

1980 ~ 90년대에 이 이론을 토대로 많은 프로토타입 기반 언어가 생겨났습니다.

<br/>

프로토타입 기반 OOP 언어의 특징은 다음과 같습니다.

<br/>

- 프로토타입 언어는 분류를 생각하지 않는다. 생성된 객체 위주로 유사성을 정의한다.
- **어휘, 쓰임새는 맥락에 의해 평가**된다.
  - **실행 컨텍스트, 스코프 체인**이 여기서 파생되었습니다.
  - 클로저, this 호이스팅 등등.. 이 모든 것들이 **프로토타입의 맥락을 표현**하기 위한 것 입니다.

<br/>

```javascript
function 참새() {
  this.날개갯수 = 2;
  this.날수있나 = true;
}

const 참새1 = new 참새();
// 날개가 2개, 날 수 있는 참새1이 있습니다.

console.log('참새의 날개 갯수 : ', 참새1.날개갯수); // 2

function 닭() {
  this.벼슬 = true;
}

닭.prototype = 참새1; // reference(오른쪽이 인스턴스인 점 주목)

// 참새1을 프로토타입으로 갖는 닭1이 생겼습니다.
// 여기에서 주목해야 할 점은 오른쪽이 참새(함수)가 아니라 참새1(인스턴스)인 점입니다.
// 프로토타입이론은 이미 존재하는 사물을 통해 범주화 한다는 점에서 일치합니다.

const 닭1 = new 닭();

console.log('닭1 날개 : ', 닭1.날개갯수, ', 날수있나? ', 닭1.날수있나); // 2, true
// 프로토타입 체인에 의해 참새 1의 속성에 접근했기 때문에 닭 함수에는 없지만 날개의 갯수가 존재하는 것을 볼 수 있습니다.

닭1.날수있나 = false;
// 닭1은 날 수 없다고 합니다. 닭1은 날 수 없어도 프로토타입에 해당하는 참새1은 날 수 있습니다.
// ( 닭1은 참새1 프로토타입에서 조금 더 멀어졌습니다. )
// 같은 속성을 변경해도 프로토타입 객체의 속성은 변경되지 앟ㄴ는 점에 주의!

console.log('다시 물어본다. 닭1은 날 수 있나? :', 닭1.날수있나); // false
```

![스크린샷 2022-05-26 오후 2.13.34.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e1270460-59d1-40a0-a70e-205b46a01e6c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.13.34.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050129Z&X-Amz-Expires=86400&X-Amz-Signature=f53d47dde33ef44a6ab34b408df80eff95b1d13d1623e6b066b75edbc23feee3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-26%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25202.13.34.png%22&x-id=GetObject)

<br/>

- 닭1의 원형은 참새1이다.
- **닭1에 없는 속성 날개 갯수는 프로토타입 체인을 통해 참조**된다.
- 닭1에 동일한 **속성명 날수있나를 추가해도 원형은 변하지 않습니다. → 위임**

<br/>

## 4. 자바스크립트 → 어휘적 범위 ( lexical scope )

<br/>

의미사용이론에 따르면, 단어의 의미는 그 어휘적인 근처 환경에서의 의미가 됩니다.

<br/>

이는 Javascript에 다음처럼 적용됩니다.

<br/>

> **변수의 의미는 그 어휘적인 (Lexical), 실행 문맥 (Execution Context)에서의 의미**가 된다.

<br/>

그렇기 때문에 **동일 범위 ( 실행 문맥 )의 모든 선언을 참고해 ( 호이스팅 ) 의미를 정의**합니다.

<br/>

호이스팅은 자바스크립트에서 악명 높기로 유명한 특징들 중 하나입니다.

<br/>

프로토타입 기반 언어인 **자바스크립트에서 단어의 의미가 사용되는 근처 환경에서의 근처를 어휘적인 범위**로 정의했습니다.

<br/>

**자바스크립트 엔진은 코드가 로드될 때 실행 컨텍스트를 생성하고 그 안에 선언된 변수, 함수를 실행 컨텍스트 최상단으로 호이스팅** 합니다.

<br/>

이러한 범위를 렉스컬 스코프라고 합니다.

<br/>

```jsx
1. // 전역 실행문맥 생성. 전체 정의(name, init) 호이스팅
2. var name = 'Kai';
3. init(); // init 실행문맥 생성. 내부 정의(name, displayName) 호이스팅
4. function init() {
5.    var name = "Steve";
6.    function displayName() {
7.      console.log(name); // 현재 실행문맥 내에 정의된게 없으니 outer 로 chain
8.      // var name = 'troll?'; // 주석 해제되면 호이스팅
9.    }
10. displayName(); // displayName 실행문맥 생성. 내부 정의 호이스팅.
11.}
```

<br/>

- **2L** → 코드가 로드될 때 전역 실행 컨텍스트가 생성됩니다. 전역의 선언부를 모두 호이스팅 하게 되는데, 여기선 2L의 `name` 과 4L의 `init` 이 렉스컬 스코프에 들어갑니다.
- **3L** → 렉시컬 스코프 상에 4L의 `init` 함수가 존재하니 에러 없이 실행할 수 있습니다. 코드 로딩 시점에 `init` 함수를 타고 들어가 실행 문맥을 생성합니다.
- **4L** → init 함수에 대한 렉시컬 스코프를 생성합니다. `name`과 `displayName` 이 들어옵니다.
- **6L-9L** → displayName 실행 문맥 내에 `name` 이라 선언된 것이 없습니다. 이럴 땐 **Scope Chain을 통해 상위 실행 컨텍스트로 위임**합니다.

코드를 로드하게 되면 아래와 같은 구조가 생성됩니다.

```jsx
- Global Execution // 1
   - Lexical : name, init

- Execution : init // 2
   - Lexical : name, displayName
   - Outer : global

- Execution : displayName // 3
   - Lexical : null
   - Outer : init
```

<br/>

대략 아래와 같은 그림으로 이해하면 될 것 같습니다.

<br/>

가장 바깥 원에서부터 안쪽 원으로 Scope Chain을 하게 됩니다.

<br/>

위에서 봤던 로쉬의 프로토타입 모델과 비슷하죠?

<br/>

자바스크립트에서의 스코프 체인, 프로토타입 체인 모두 이 그림으로 표현됩니다.

<br/>

![스크린샷 2022-05-26 오후 2.43.04.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3457738e-5006-4ed7-befc-2f75c6f5c59d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.43.04.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050257Z&X-Amz-Expires=86400&X-Amz-Signature=510ec3611b4c438c7899f70ddaaae6caf3583f6ce67a575857844ce093a025f0&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-26%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25202.43.04.png%22&x-id=GetObject)

<br/>

여기서 중요한 것은 자바스크립트의 동작 방식보다는, 프로토타입 언어인 **자바스크립트에 도대체 왜 ‘실행 문맥’, ‘렉시컬 스코프’, ‘호이스팅' 이 존재하는가 입니다.**

<br/>

왜를 이해하셨다면 이 부분은 더이상 암기 과목이 아닙니다.

<br/>

프로토타입 철학의 근원인 비트겐슈타인류에서 가장 중요하게 생각하는 것이 바로 **‘어휘'이고 이 것은 문맥내에서만 의미를 가진다는 것이 핵심**입니다.

<br/>

이 핵심을 자바스크립트에서 구현하기 위해 자연스럽게 발생한 특징임을 이해하신다면, 더이상 외울 필요가 없어집니다.

<br/>

## 5. 자바스크립트 - this

<br/>

자바스크립트에 또 다른 악명으로 유명한 특징은 바로 `this` 입니다.

<br/>

아래는 `this`에 대한 대표적인 오해들입니다.

<br/>

- `this` 는 기본적으로 window이다. ( X )
- 이벤트 리스너에 등록한 콜백의 `this`는 내부에서 bind 등을 통해 바뀌기 때문에 무엇인지 알 수 없다. ( X )
- `this`는 외워야 한다. ( X )

<br/>

이러한 오해를 바로잡기 위해선 먼저 프로토타입 철학에서 이러한 상황을 어떻게 해석하는지 알 필요가 있습니다.

<br/>

비트겐슈타인은 **그의 대표적인 저서 철학적 탐구에서 단어의 쓰인새가 곧 의미라는 점을 강조**했습니다. ( 의미 사용 이론 )

<br/>

그는 이를 발화라고 이야기했는데, 위에서 예시를 들었던 것 처럼, **“벽돌!”이라고 크게 외칠 때, 그것이 어디서 발화 되느냐에 따라서 단어의 의미가 달라집니다.**

<br/>

좀더 쉽게 이야기 하면, **받아들이는 대상에 따라서 같은 단어도 의미가 달라진다는 이야기** 입니다.

<br/>

이것이 바로 프로토타입과 클래스의 대표적인 차이라고 볼 수 있습니다.

<br/>

전혀 다르게 단어를 보는 방식이고 중요한 세계관의 차이입니다.

<br/>

미리 분류하고 정의한 **클래스를 가장 중요하게 여기는 전통적인 방식과는 달리, 프로토타입에서는 받아들이는 주체와 문맥**이 가장 중요한 것이죠.

<br/>

즉, **프로그래밍으로 보자면 실행하는 객체가 중요**하다는 의미입니다.

<br/>

프로토타입 기반 언어에서는 this가 정의된 함수가 어떻게 발화 되었는지에 따라 가리키는 값이 달라집니다.

<br/>

**정확히는 받아들이는 대상의 컨텍스트를 가리킵니다.**

<br/>

이를 이해하기 위해 먼저 메서드와 메시지를 명확하게 알아야 합니다.

<br/>

- 메소드 → 객체의 함수
- 메시지 → 메소드를 실행하라는 메시지 전달

<br/>

자바에서는 **클래스의 메소드를 호출하는 행위를 메시지**라고 합니다.

<br/>

자바스크립트로 예를 들면 foo라는 객체가 있고 그 내부에서 bar()라는 함수가 있을 때 다음처럼 발화 할 객체를 지정할 수 있습니다.

<br/>

- **foo**.bar()
- bar.call(**foo**)
- var boundBar = bar.bind(**foo**)

<br/>

위처럼 **foo 객체를 통해 발화한 함수는 내부 this가 무조건 foo를 가리킵니다.**

<br/>

만약, 아무것도 지정되어있지 않으면 global or window를 가리킵니다.

<br/>

좀더 자세히 알기 위해 예시를 준비했습니다.

<br/>

```javascript
var someValue = 'hello';
function outerFunc() {
  console.log(this.someValue); // 첫번째 : ?, 두번째 : ?
  this.innerFunc();
}
const obj = {
  someValue: 'world',
  outerFunc,
  innerFunc: function () {
    console.log("innerFunc's this : ", this); // 첫번째 : ?, 두번째 : ?
  },
};
obj.outerFunc(); // 첫번째
outerFunc(); // 두번째
```

<br/>

- `obj.outerFunc();`

  - 여기에서 발화된 주체는 `obj` 입니다.
  - 따라서, `this`는 `obj` 를 가리키게 될 것이며 world가 찍히게 됩니다.

- `outerFunc();`
  - 여기서 발화된 주체는 `window` 입니다.
  - 따라서, this는 window를 가리키게 될 것이며 hello가 찍히게 됩니다.

<br/>

그럼 4번째 줄 `this.innerFunc();` 의 경우에는 어떻게 될까요?

<br/>

`obj.outerFunc()` 의 경우에는 발화된 주체는 `obj` 입니다.

<br/>

따라서, 오류 없이 정상적으로 출력이 되겠지만 `outerFunc()` 발화의 주체는 window입니다.

<br/>

그런데, window의 this에는 `innerFunc()`가 존재하지 않습니다. 그러기 때문에 에러가 발생할 것입니다.

<br/>

### obj.outerFunc()의 호출 상황

<br/>

![스크린샷 2022-05-27 오후 1.15.19.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/40e7811b-98d1-4585-a890-f137a0c71404/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.15.19.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050437Z&X-Amz-Expires=86400&X-Amz-Signature=b48772584ce5c5c8464aa7883fb1070b612ebeeff49e51d296ae68c88291d794&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-27%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.15.19.png%22&x-id=GetObject)

<br/>

- **시작** → 자바스크립트 엔진이 코드를 실행합니다.
- **1번**
  - 코드에서 `obj.outerFunc();` 이 호출되면 엔진은 `obj` 에 `outerFunc` 를 실행하라는 메시지를 보냅니다.
- **2번**
  - `obj`에서 `outerFunc`를 발화합니다. 코드 로드 시 만들어져있는 실행 문맥을 참고해 실행합니다.
  - 이 때 실행 문맥상의 `this`는 발화한 `obj`를 가리킵니다.
- **3번**
  - 실행중에 this.innerFunc를 만납니다.
  - 엔진은 this가 가리키는 obj에 innerFunc를 실행하라는 메시지를 보냅니다.
- **4번**
  - `obj`에 `innerFunc`이 선언되어있으나, 잘 실행합니다.

<br/>

### outerFunc() 호출 상황

<br/>

![스크린샷 2022-05-27 오후 1.21.30.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7f7734c5-2f01-445f-a95e-a27677bfe21c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.21.30.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050501Z&X-Amz-Expires=86400&X-Amz-Signature=300e89b4fa30c2fc1f73d1e0f43cf169744a587fff26b7dba789f41740c45e72&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-27%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.21.30.png%22&x-id=GetObject)

<br/>

- **1번**
  - 코드에서 `outerFunc` 를 호출하게 되면 엔진은 자신 ( global )의 실행 문맥상에 존재하는 `outerFunc` 을 호출합니다.
- **2번**
  - 발화한 지점이 global이니 `this`는 엔진을 가리킵니다.
  - 엔진에 `innerFunc`을 실행하라는 메시지를 보냅니다.
- 3번
  - 글로벌 실행 문맥에는 `innerFunc`이 없기 때문에 에러가 납니다.

<br/>

그럼 예시를 한 개 더 보겠습니다.

<br/>

```javascript
<body>
  <button>눌러!</button>
  <script src="./app.js"></script>
</body>

--------

function handle() {
    console.log(this);
}

document.querySelector('button').addEventListener('click', handle);

handle();
```

<br/>

이와 같은 예제는 어떤 결과가 찍히게 될까요?

<br/>

결과는 다음과 같습니다.

<br/>

![스크린샷 2022-05-27 오후 1.38.13.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e39fe218-2082-4027-9783-d6ba624e7877/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.38.13.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050540Z&X-Amz-Expires=86400&X-Amz-Signature=d9f9674a978e5c1806d34c8256b6607bc14f32a2880746acc065e892d685156d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-27%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.38.13.png%22&x-id=GetObject)

<br/>

이 또한 발화지점을 생각하면 전혀 햇갈리지 않는 예제였습니다.

<br/>

![스크린샷 2022-05-27 오후 1.39.06.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0efa17f5-df6b-48af-aa87-c39c4c5ff8a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.39.06.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220527%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220527T050551Z&X-Amz-Expires=86400&X-Amz-Signature=c5d56fd30fc8688d3ec4be34950b6a675de72b0d90e54d3a5ab70ec7d2c1c5d5&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-05-27%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.39.06.png%22&x-id=GetObject)

<br/>

- **1번**
  - 브라우저에서 `button`을 클릭하면 엔진이 반응합니다.
- **2번**
  - 해당 엘리먼트 ( **button** )에 등록된 eventListener를 실행하라는 메시지를 보냅니다.
- **3번**
  - **button** 엘리먼트에서 **handle**을 발화합니다.
- **4번**
  - 이때 handle의 실행 문맥의 this는 발화된 **button**을 가리킵니다.

<br/>

## 6. 마무리

<br/>

드디어 프로토타입에 대한 긴 여정이 마무리 되었습니다.

<br/>

프로토타입은 클래스의 다른 구현이 아닌, 완전히 새로운 인식 하에 만들어진 이론입니다.

<br/>

이러한 차이점을 이해하게 된다면 더 이상 JS의 프로토타입, 호이스팅, this는 암기 과목이 아니게 됩니다.

<br/>

최근 자바스크립트 스펙에서 `class`, `arrow function`, `let`, `const` 등 여타 일반적인 언어와 보편성을 맞추려는 시도도 많고 이것들을 정말 편하게 사용 중 이지만, 근본 ( 프로토타입 )은 변하지 않는다는 것을 알아야 합니다.

<br/>

또한 이것들이 언어적 지원이 아닌 문법적 설탕인 부분도 언어의 근본 구조가 다르기 때문임을 이해할 수 있습니다.

<br/>

지금도 많은 구두들이 JS의 디자인 철학 ( 프로토타입 )을 해치지 말자고 주장하고 있습니다.

<br/>

이러한 흐름을 이해하려면 언어의 디자인 철학을 이해 할 필요가 있을 것 같습니다.

<br/>

## 7. 출처

- [자바스크립튼 왜 프로토타입을 선택했을까?](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)
